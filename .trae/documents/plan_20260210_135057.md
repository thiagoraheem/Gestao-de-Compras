# Arquitetura de Dados Proposta: Isolamento de Fases e Correção de Seleção Parcial

Para resolver o problema de propagação incorreta de itens (bug de seleção parcial) e garantir a independência entre as fases, propomos a introdução de uma camada de **Snapshot de Aprovação** entre a Cotação e o Pedido de Compra.

## 1. Nova Estrutura de Dados: `approved_quotation_items`

Criaremos uma tabela intermediária que atua como *source of truth* para o que foi efetivamente selecionado para compra. Isso elimina a dependência de flags mutáveis (`isAvailable`) na tabela de ofertas do fornecedor.

### Schema da Tabela

```typescript
export const approvedQuotationItems = pgTable("approved_quotation_items", {
  id: serial("id").primaryKey(),
  quotationId: integer("quotation_id").references(() => quotations.id).notNull(),
  supplierQuotationItemId: integer("supplier_quotation_item_id").references(() => supplierQuotationItems.id).notNull(),
  purchaseRequestItemId: integer("purchase_request_item_id").references(() => purchaseRequestItems.id).notNull(),
  
  // Snapshot dos valores no momento da seleção
  approvedQuantity: decimal("approved_quantity", { precision: 10, scale: 3 }).notNull(),
  unitPrice: decimal("unit_price", { precision: 15, scale: 4 }).notNull(),
  totalPrice: decimal("total_price", { precision: 15, scale: 4 }).notNull(),
  
  createdAt: timestamp("created_at").defaultNow().notNull(),
});
```

## 2. Fluxo de Transição Refatorado

### A. Seleção de Fornecedor (`/select-supplier`)

**Como é hoje:** Atualiza flag `isAvailable` na tabela `supplier_quotation_items`.
**Como ficará:**

1. Recebe os itens selecionados/não selecionados.
2. **Limpa** quaisquer registros anteriores em `approved_quotation_items` para esta cotação (permite re-seleção).
3. **Insere** novos registros em `approved_quotation_items` *apenas* para os itens que o usuário escolheu comprar.
4. Itens não selecionados simplesmente não terão registros nesta tabela.

### B. Aprovação A2

**Como é hoje:** O aprovador vê dados da cotação.
**Como ficará:** O aprovador valida os dados persistidos em `approved_quotation_items`. Isso garante que ele aprove exatamente o que será gerado no pedido.

### C. Geração do Pedido (`createAutomaticPurchaseOrder`)

**Como é hoje:** Itera sobre `supplier_quotation_items` e checa `isAvailable`.
**Como ficará:**

1. Consulta `approved_quotation_items` vinculados à cotação.
2. Gera os itens do pedido (`purchase_order_items`) baseando-se estritamente nesta lista.
3. Resultado: Impossível gerar itens "extras" pois eles não existem na tabela de aprovação.

## 3. Plano de Implementação

### Passo 1: Migração de Banco de Dados

* Criar a tabela `approved_quotation_items` no arquivo `shared/schema.ts`.

* Criar script de migração para popular tabela com base em cotações passadas (se necessário para histórico, caso contrário, aplica-se a novas). Preferencialmente buscar os dados dos pedidos de compra confirmados, para evitar popular com itens que não foram aprovados/selecionados.

### Passo 2: Backend - Lógica de Seleção

* Modificar a rota `POST /api/quotations/:quotationId/select-supplier` em `server/routes.ts`.

* Implementar a lógica de inserção snapshot.

### Passo 3: Backend - Geração de Pedido

* Modificar `createAutomaticPurchaseOrder` em `server/routes/approval-rules.ts`.

* Alterar a fonte de dados para ler da nova tabela.

### Passo 4: Verificação e Testes

* Criar um cenário de teste: Solicitação com 3 itens -> Cotação com 3 itens -> Selecionar Fornecedor mas escolher apenas 2 itens.

* Verificar se `approved_quotation_items` tem 2 registros.

* Aprovar A2.

* Verificar se `purchase_order_items` tem exatos 2 registros.

## Benefícios

* **Correção Definitiva do Bug:** A lógica de exclusão muda de "tentar filtrar o que não quero" para "incluir apenas o que eu quero".

* **Auditabilidade:** Temos um registro claro do que foi enviado para aprovação, separado da oferta bruta do fornecedor.

* **Independência:** Alterações futuras na tabela do fornecedor não afetam o snapshot da aprovação.

